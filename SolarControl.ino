/*
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/4a9a100c-5b40-40d7-bff3-18d7af077d3d
  CloudElectricPotential solarVoltage;
  CloudElectricPotential batteryCurrent;
  CloudElectricPotential batteryVoltage;

*/
#include "ADS1X15.h"
#include "thingProperties.h"

// Variables for Measured Voltage and Calculated Current
double Vout = 0;
//double Current = 0;

// Constants for Scale Factor
// Use one that matches your version of ACS712

const double scale_factor = 0.185; // 5A
//const double scale_factor = 0.1; // 20A
//const double scale_factor = 0.066; // 30A

// Constants for A/D converter resolution
// Arduino has 10-bit ADC, so 1024 possible values
// Reference voltage is 5V if not using AREF external reference
// Zero point is half of Reference Voltage

const double R1_1 = 20;
const double R2_1 = 2.8;
const double vRef = 5;
//const double resConvert = 1717;
const double resConvert = 1690;
double resADC = vRef / resConvert;
double zeroPoint = vRef / 2;

ADS1115 ADS(0x48);

void setup() {
  // Initialize serial and wait for port to open:
  //  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  //  delay(1500);

pinMode(D4, OUTPUT);

  // Defined in thingProperties.h
    initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */


  ADS.begin();
  ADS.setGain(0);

  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here
  // Handle output control
  // if (Switch1) {
  //   digitalWrite(4, HIGH);  // Turn on output D4
  // } else {
  //   digitalWrite(4, LOW);   // Turn off output D4
  // }
  // Vout is read 1000 Times for precision
  for (int i = 0; i < 1000; i++) {
    Vout += resADC * analogRead(A0);
    //  delay(1);
  }

  // Get Vout in mv
  Vout = Vout / 1000;

  // Convert Vout into Current using Scale Factor
  batteryCurrent = (Vout - zeroPoint) / scale_factor;

  // float voltage = (sensorValue / 1023.0) * 5.0; // Convert the sensor value to voltage (assuming 5V Arduino board)
  // float current = (voltage - 2.5) / 0.066; // Convert the voltage to current using the sensitivity of the sensor (66mV/A for ACS712-05A)

  delay(1000);

  int16_t val_01 = ADS.readADC_Differential_0_1();
  int16_t val_23 = ADS.readADC_Differential_2_3();
  float volts_01 = ADS.toVoltage(val_01);
  float volts_23 = ADS.toVoltage(val_23);

  // batteryCurrent = 1;
  solarVoltage   = -volts_01 * (R1_1 + R2_1) / R2_1;
  batteryVoltage = -volts_23 * (R1_1 + R2_1) / R2_1;
}
/*
  Since Mes is READ_WRITE variable, onMesChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMesChange()  {
  // Add your code here to act upon Mes change
}
/*
  Since Switch1 is READ_WRITE variable, onSwitch1Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onSwitch1Change()  {
  
  if (switch1) {
    digitalWrite(D4, LOW);  // Turn on output D4
      } else {
    digitalWrite(D4, HIGH);   // Turn off output D4
      }
  // Add your code here to act upon Switch1 change
}
